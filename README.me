================================================================================
PROJEKT: Energieeffizientes Kubernetes-Scheduling (Master-Thesis)
================================================================================

AUTOR: Dorian Gohdes
DATUM: 2025-11-11
AKTIVE VERSION: v1.1-normalized-static


================================================================================
1. PROJEKTZIEL
================================================================================

Der Standard-Kubernetes-Scheduler ("default-scheduler") ist "energie-agnostisch".
Er verteilt Workloads (Pods) basierend auf quantitativen Anfragen (z.B.
"benoetigt 1 CPU"), ignoriert aber die qualitativen Hardware-Eigenschaften
(z.B. "langsame ARM-CPU" vs. "leistungsstarke x86-CPU"). In einem
heterogenen Cluster fuehrt dies zu suboptimalem Energieverbrauch.

Dieses Projekt implementiert einen benutzerdefinierten Kubernetes-Scheduler,
der ML-Workloads (definiert durch Profile) intelligent auf dem
geeignetsten, verfuegbaren Knoten platziert, um den Energieverbrauch zu
minimieren, waehrend die vom Benutzer gewuenschte Leistung erbracht wird.


================================================================================
2. ARCHITEKTUR & KOMPONENTEN
================================================================================

Das System besteht aus drei unentbehrlichen Komponenten:

1. STATISCHE WISSENSDB (/benchmarks/knowledge-base.yaml)
   - Zweck: Enthaelt die Benchmark-Ergebnisse (Performance, Energieverbrauch)
     fuer jeden Knoten und jeden Workload-Typ ("training", "inference",
     "sequential").
   - Erstellung: Wird manuell durch Ausfuehrung der Skripte in /benchmarks/
     erstellt und als K8s ConfigMap geladen.

2. SCHEDULER-PLUGIN (/scheduler-plugin/)
   - Zweck: Die "Intelligenz" des Projekts. Dieses Go-Plugin ersetzt den
     Default-Scheduler fuer markierte Pods.
   - Logik: Liest die statische Wissensdatenbank (ConfigMap), um fuer jeden
     Knoten einen Score zu berechnen.

3. ECHTZEIT-MONITOR (/energy-monitor/)
   - Zweck: Stellt dynamische Daten bereit (fuer den zukuenftigen
     hybriden Scheduler).
   - Logik: Ein Python-Dienst, der Shelly-Steckdosen abfragt und den
     aktuellen Stromverbrauch als Annotation (energy.thesis.io/current-watts)
     an das K8s-Node-Objekt schreibt.


================================================================================
3. AKTUELLER STATUS & VERSIONIERUNG
================================================================================

Die Versionierung ist entscheidend fuer die Evaluation.

---
VERSION: v1.0-static (Tag: v1.0-static)
---
- STATUS: Stabil, im Git-Tag "v1.0-static" gesichert.
- LOGIK: Liest statische Profile. Verwendet eine fehlerhafte Scoring-Formel,
  bei der Rohwerte (z.B. Performance=22036) direkt mit Effizienz=310
  verglichen werden. Dies fuehrt dazu, dass der Nutzerparameter
  ("performance-weight") fast wirkungslos ist und alle Scores auf 100
  abgeschnitten werden.

---
VERSION: v1.1-normalized-static (Tag: v1.1-normalized-static) - AKTIV
---
- STATUS: Stabil, im Git-Tag "v1.1-normalized-static" gesichert.
- LOGIK: Behebt das Problem von v1.0 durch Normalisierung.
- PRE-SCORE PHASE: Ermittelt die clusterweiten Maxima fuer Performance (maxP)
  und Effizienz (maxE) fuer den angeforderten Workload-Typ.
- SCORE PHASE: Berechnet fuer jeden Knoten einen normalisierten Score (0-100)
  fuer Leistung (normP) und Effizienz (normE).
- FINALE FORMEL: Score = (Gewicht * normP) + ((1 - Gewicht) * normE)
- ERGEBNIS: Der Nutzerparameter funktioniert jetzt korrekt. Der Scheduler
  trifft eine ausgewogene Entscheidung, wie die Logs (finalScore: 45 vs 31)
  beweisen.

---
VERSION: v2.0-hybrid (ZUKUNFT)
---
- STATUS: Naechster logischer Schritt (Branch "feature/hybrid-scheduler").
- LOGIK: Erweitert v1.1. Nutzt zusaetzlich den /energy-monitor.
- HYBRID-CHECK: Liest die Echtzeit-Annotation "current-watts" vom Knoten.
  IF (currentWatts > (idlePowerWatts + Puffer))
      // Knoten ist belegt
      return 0
  ELSE
      // Knoten ist frei, verwende normalisierte Formel aus v1.1
      return normalizedScore


================================================================================
4. BUILD-PROZESS & IMAGE-STRUKTUR
================================================================================

Alle Images werden mit `nerdctl` und `buildkitd` direkt in die `k8s.io`
Namespace der k3s-Container-Runtime gebaut und in die lokale Registry
(192.168.178.136:5000) gepusht.

---
4.1 Scheduler-Plugin (my-energy-scheduler)
---
- DOCKERFILE: plugin/kubernetes/Dockerfile
- IMAGE-STRUKTUR: Basiert auf `registry.k8s.io/build-image/go-runner`.
  Enthaelt nichts weiter als das kompilierte `kube-scheduler` Go-Binary,
  das unser `plugin.go` beinhaltet.
- BUILD-PROZESS (Komplex, da "in-tree" kompiliert):

    # 1. (Optional) Git-Branch fuer Aenderungen erstellen
    cd ~/thesis-energy-scheduler
    git checkout -b feature/meine-neue-aenderung

    # 2. Geaenderten Code in das K8s-Build-Verzeichnis kopieren
    cp ~/thesis-energy-scheduler/scheduler-plugin/plugin.go \
       ~/plugin/kubernetes/staging/src/k8s.io/myenergyplugin/myenergyplugin.go

    # 3. Go-Binary kompilieren
    cd ~/plugin/kubernetes
    make kube-scheduler

    # 4. Build-Daemon starten (falls nicht schon laeuft)
    sudo buildkitd &

    # 5. Image bauen (TAG anpassen!)
    export TAG=v2.2-meine-aenderung
    export REGISTRY_IP=192.168.178.136:5000
    sudo nerdctl --address /run/k8s/containerd/containerd.sock -n k8s.io \
      build . -t $REGISTRY_IP/my-energy-scheduler:$TAG

---
4.2 Python-Images (z.B. energy-monitor, benchmarks)
---
- DOCKERFILES: z.B. energy-monitor/Dockerfile, benchmarks/cpu/Dockerfile.cpu.multiarch
- IMAGE-STRUKTUR:
    - `energy-monitor`: Basiert auf `python:3.9-slim`. Installiert `requests`
      und `kubernetes-client` via pip und kopiert das `energy_monitor.py` Skript.
    - `benchmark-cpu`: Basiert auf `python:3.9-slim-bullseye`. Installiert
      `build-essential` via apt und `numpy` via pip.
    - `benchmark-gpu`: Basiert auf `pytorch/pytorch:2.1.0-cuda...`. Kopiert
      nur das `gpu-task.py` Skript (PyTorch ist im Base-Image).
- BUILD-PROZESS (Einfach, da "standalone"):

    # 1. In das Verzeichnis des jeweiligen Dockerfiles wechseln
    cd ~/thesis-energy-scheduler/energy-monitor

    # 2. Build-Daemon starten
    sudo buildkitd &

    # 3. Image bauen (TAG und NAME anpassen!)
    export IMAGE_NAME=energy-monitor
    export IMAGE_TAG=v1.1
    export REGISTRY_IP=192.168.178.136:5000
    sudo nerdctl --address /run/k8s/containerd/containerd.sock -n k8s.io \
      build . -t $REGISTRY_IP/$IMAGE_NAME:$IMAGE_TAG


================================================================================
5. IMAGE-DEPLOYMENT (PUSH & APPLY)
================================================================================

Ein Image zu bauen, laedt es noch nicht in die Registry.

---
5.1 Image in die lokale Registry pushen
---
JEDES neu gebaute Image muss gepusht werden, damit K8s es finden kann.

    export IMAGE_NAME=my-energy-scheduler
    export IMAGE_TAG=v2.1-normalized
    export REGISTRY_IP=192.168.178.136:5000

    sudo nerdctl --address /run/k8s/containerd/containerd.sock -n k8s.io \
      push --insecure-registry $REGISTRY_IP/$IMAGE_NAME:$IMAGE_TAG

---
5.2 Deployment aktualisieren (Zwei Szenarien)
---

**SZENARIO A: Sie haben ein neues IMAGE gebaut (Code-Aenderung)**

Sie muessen dem K8s-Deployment sagen, dass es das neue Image-Tag verwenden soll.
Der Pod wird automatisch neu gestartet.

    kubectl set image deployment/my-energy-scheduler -n kube-system \
      scheduler=192.168.178.136:5000/my-energy-scheduler:v2.1-normalized

**SZENARIO B: Sie haben eine KONFIGURATION geaendert (YAML-Aenderung)**

Der Scheduler-Pod liest seine Konfiguration (`my-scheduler-config.yaml`) nur
beim Start. Ein `kubectl apply` reicht NICHT aus.

    # 1. Aenderung im Cluster anwenden
    cd ~/thesis-energy-scheduler
    kubectl apply -f scheduler-plugin/k8s/my-scheduler-config.yaml

    # 2. Neustart des Schedulers erzwingen, um die neue Konfig zu laden
    kubectl delete pod -n kube-system -l app=my-energy-scheduler
